/* from https://github.com/gibbedy/BeatDetector

# BeatDetector
 poor mans beat detection for audio played through a teensy audio board.

 When combined with the teensy audio libraries FFT object it detects low/med/high frequency beats in audio played.

 To use create a BeatDetector object passing it a pointer to an AudioAnalyzeFFT256 object created using the teensy audio library
 Once per loop call BeatDetectorLoop().
 To determine if beat was detected just check objects public variables lowBeat/midBeat/highBeat



  BEAT DETECTION ALGORITHYM:
 * A running average of the magnitude of the fft signal is kept for each low/med/high bin range.
 * The maximum magnitude of fft signal seen in the last second is updated every second (or so)
 * The differnce between average and max audio values is calculated and a beat detection threshold is set between these two values determined by a threshold factor that you can set.
 * If the current audio signal is greater than this threshold then it is a beat.
 * Retriggering of beat detection is locked out for a preset amount of time. (see variables somewhere below)
 * set enableSerialBeatDisplay true and use arduino serial plotter to visualise whats going on.
 * I'm  also experimenting  generating a virtual beat signal. This is generated with bpm timing every time a valid bpm is measured
 * Until a valid bpm is measured, virtualbeat will mirror low beat

 Teensy3.2 + Audo board.
 compile audioAnalyzeDetectBeat.ino with defines for how audio is to be played (line in/mic/sd card playback)

 Note:
 I don't think I implemented mid/high or if I did its dodgy.
 Comments that make sense mean that section of code was probably copied/pasted from someone else.
 Comments may not be relevant as I was constantly changing values to get what looked ok.
 This is not an example of good code. I'm a novice.

 If you have a teensy3.2 and audio board and an sdcard and a wav file (in correct format) you could play through usb audio and test this without any other hardware.

 In arduino IDE open up serial plotter to see what is going on.

 https://www.youtube.com/watch?v=E-PomXjd1eQ


 I believe my inspiration and probably allot of code came from this guy:
 https://github.com/saikoLED/TeensyLED/tree/master/Examples/TeensyLED_Audio_DMX_Master
 so thank you :).
  */


/*
 * This is my BeatDetector class
 * When combined with the teensy audio libraries FFT object it detects low/med/high frequency beats in audio played.
 * 
 * To use create a BeatDetector object passing it a pointer to an AudioAnalyzeFFT256 object created using the teensy audio library 
 * Once per loop call BeatDetectorLoop().
 * To determine if beat was detected just check objects public variables lowBeat/midBeat/highBeat 
 */

/*
* BEAT DETECTION ALGORITHYM:
* A running average of the magnitude of the fft signal is kept for each low/med/high bin range.
* The maximum magnitude of fft signal seen in the last second is updated every second (or so)
* The differnce between average and max audio values is calculated and a beat detection threshold is set between these two values determined by a threshold factor that you can set.
* If the current audio signal is greater than this threshold then it is a beat.
* Retriggering of beat detection is locked out for a preset amount of time. (see variables somewhere below)
* set enableSerialBeatDisplay true and use arduino serial plotter to visualise whats going on.
*
* I'm  also experimenting  generating a virtual beat signal. This is generated with bpm timing every time a valid bpm is measured
* Until a valid bpm is measured, virtualbeat will mirror low beat
*
*/

#ifndef BEATDETECTOR_H
#define BEATDETECTOR_H

#include <Audio.h>

class BeatDetector {
public:
  AudioAnalyzeFFT256 *fft256_1; //pointer to fft object from audio library
  BeatDetector(
      AudioAnalyzeFFT256 &); //constructor takes a refernce to get fft data from audio library
  bool
  BeatDetectorLoop(); //method to call in programs loop to perform beat detection

  float lowBeat = 0;   // non-zero if low frequency beat was detected after last BeatDetectorLoop was run. value was going to be beat level or something but I haven't done that yet.
  float midBeat = 0;   //yada
  float highBeat = 0;  //yadaYada
  bool virtualBeat = false;             //virtual beat generated by calculating bpm and setting this true
  bool musicStopped = false;             //if music has changed from paying to stopped this flag is true for one scan
  bool musicPlaying = false;             //True if music has been detected as playing
  bool validBPM = true;           //true if a valid bpm is currently detected.
  bool fftDataAvailable = false;    //program that is using beatDetector may want to access raw fft data
  //so I pass a flag to show when new data is available.
  uint8_t bpm = 0; //beats per minute that are detected. I'm thinking of having this info sent to led teensy value of 0 will be used for invalid reading
  bool enableSerialBeatDisplay = true;    //set true to display a graphical view of beat detection when used with arduino serial plotter
  uint32_t fftCount = 0; //number of fft samples made in last second

private:

  bool BeatDetectorUpdate(float &, float &, float &, float &, float *, int &,
                          const int, float &, float &, float &, elapsedMillis &,
                          int &);

  elapsedMillis musicPlayingStatusTime = 0;  //music playin status update will be sent a regular intervals below.
  const int musicPlayingStatusInterval = 5000;

//I need to determine if music is playing or rather if beats are being detected
//I could do this by listening for a beat and if none heard for a period of:
  uint32_t noBeatDuration = 3000;

  elapsedMillis beatCountTimer = 0;//timer for above nobeatduration
  uint32_t beatCountTime = 0;
  elapsedMillis virtualBeatTimer = 0;    //time sinnce last virtual beat
  uint32_t virtualBeatTime = 0;        //current period of virtual beat
  elapsedMillis virtualBeatRetriggerTimer = 0;  //timer to lock out double pulses when using virtualBeat
  uint32_t virtualBeatRetriggerTime = 200;    //minimum time between virtual beats using timer above.
//Then I clear a varialbe to say music is not playing:

  bool musicWasPlaying = false;//old status of music used to tell when state changes and updates variable below

//if however a beat is detected I don't want to count 1 lone random noise generated beat as music playing.

//I will do this by incrementing a beatCount variable:
  uint32_t beatCount = 0;  //(this beatCount variable will be zero'd when above noBeatDuration is reached.
//and checking when it reaches a preset amount:
  uint8_t beatsRequired = 2;

//I indend to detect the beats per minute of music playing. I will do this by
//1. detecting time between last beat detected using previous beatCountTime variable and adding this to a running list of beat times
  const static int BPM_BEAT_LIST_LENGTH = 2;   //how many beat times to keep in FILO array. That is how many beat times in a row (plus one because we compare current beat time
  //with those in the array) need to be the same before bpm is considered valid.
  unsigned int beatTimes[BPM_BEAT_LIST_LENGTH];

//then check if beat times are consistent between beats (in case of list length of 4) 1-2, 2-3, 3-4

  const uint8_t BEAT_TOLERANCE = 25;  //beat intervals must be between +-10ms to be classed as the same. need to experiment
//and if they all are use that time as accepted  bpm time
//if they are not just ignore bpm calc. only clear current bpm calce when music is seen to stop playing.



//***************************************************************************************************************************************************************
//***************************************************************************************************************************************************************
//variables for BeatDetector low/mid and high
  float average = 0;
  float oldAverage = 0;
  float averageSmoothing = 0.0001;

//global variables required for runFFTLowAverage sequence
  const static int FFTLowAverageNumReadings = 115;  //with current fft 115 is aproximately 1 second.This is the amount of samples to find the average signal level I use 115 when I set averageTogether(3) but now I'm using 6 I should set to about half this which 57. Nope now I'm using 3 for averaging.
  float FFTLowAverageOldaudioValue = 0;
  float FFTLowAverageAudioValue = 0;
  float FFTLowAverageDValue = 0;
  float FFTLowAverageMaxValue = 0;                 //the max value seen during last array buffer.
  float FFTLowAverageOldMaxValue = 0;
  float FFTLowAverageReadings[FFTLowAverageNumReadings]; //the readings from the analog input
  int FFTLowAverageReadIndex = 0;                // the index of the current reading
  float FFTLowAverageTotal = 0;                  // the running total

  float FFTLowAverageThresholdFactor = .7;        //max audio value is multiplied by this to find threshold where signal is seen as a beat (.7 using old way)(1.7 using new way)
  float FFTLowAverageSilenceFactor = .75;         //max audio signal seen in the previous number of samples is multiplied by this. if the result is less than the average audio signal then beat detected is ignored (silen vocal bits in song)
  int FFTLowAverageRetriggerTime = 200;           //time that a new beat detected will be ignored

  elapsedMillis FFTLowAverageRetrigger = 0;

//global variables required for runFFTMidAverage sequence
  const static int FFTMidAverageNumReadings = 70;
  float FFTMidAverageOldaudioValue = 0;
  float FFTMidAverageAudioValue = 0;
  float FFTMidAverageDValue = 0;
  float FFTMidAverageMaxValue = 0;                 //the max value seen during last array buffer.
  float FFTMidAverageOldMaxValue = 0;
  float FFTMidAverageReadings[FFTMidAverageNumReadings];      // the readings from the analog input
  int FFTMidAverageReadIndex = 0;              // the index of the current reading
  float FFTMidAverageTotal = 0;                  // the running total

//float FFTMidAverageThresholdFactor=0.8;//changed to values below as it totaly doesn't work anymore. not sure what I did.
  float FFTMidAverageThresholdFactor = 0.4;
  float FFTMidAverageSilenceFactor = .75;
  int FFTMidAverageRetriggerTime = 100;

  elapsedMillis FFTMidAverageRetrigger = 0;

//global variables required for runFFTHighAverage sequence
  const static int FFTHighAverageNumReadings = 70;
  float FFTHighAverageOldaudioValue = 0;
  float FFTHighAverageAudioValue = 0;
  float FFTHighAverageDValue = 0;
  float FFTHighAverageMaxValue = 0;                 //the max value seen during last array buffer.
  float FFTHighAverageOldMaxValue = 0;
  float FFTHighAverageReadings[FFTHighAverageNumReadings];      // the readings from the analog input
  int FFTHighAverageReadIndex = 0;              // the index of the current reading
  float FFTHighAverageTotal = 0;                  // the running total

  float FFTHighAverageThresholdFactor = 0.07;
  float FFTHighAverageSilenceFactor = .5;
  int FFTHighAverageRetriggerTime = 150;

  elapsedMillis FFTHighAverageRetrigger = 0;


//audio analysis data sent over serial to be plotted.
//usefull to tune beat detetion.
//enable none or one of these.
  uint32_t serialPlotLow = true;
  uint32_t serialPlotMid = false;
  uint32_t serialPlotHigh = false;

  uint32_t enablePlot = false;      //flag to set/unset when doing beat detection to enable serial plot only for freq range specified in one of the three variables above.
//bools to enable/dissable plotting of beat detection variables to nextion hmi
  uint32_t enablePlot0 = 0;     //first value to plot (selected from checkbox on nextion)
  uint32_t enablePlot1 = 0;
  uint32_t enablePlot2 = 0;
  uint32_t enablePlot3 = 0;


};

#endif //BeatDetector_H
